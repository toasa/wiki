https://www.amazon.co.jp/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E5%8A%9B%E3%81%A8%E6%80%9D%E8%80%83%E5%8A%9B%E3%82%92%E9%AB%98%E3%82%81%E3%82%8B77%E3%81%AE%E6%8A%80%E8%A1%93-Compass-Books%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E7%B1%B3%E7%94%B0/dp/483997750X

# 2. 累積和

## 2.4 二次元の累積和（２）

[B09](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ch)

* (2024-04-03)
  * やり方忘れてるなー。
  * まず横方向に累積和を取り、次に縦方向に累積和を取ればいいんだった。
  * もちろん縦横逆でもいい。
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/51990732)

# 3. 二分探索

## 3.1 配列の二分探索

[B11](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cj)

* (2024-04-05)
  * めぐる式二分探索を自作してみる
    * https://github.com/toasa/tessoku-book/blob/main/toybox/bisearch_meguru.py
  * いいですねー。これを使って B11 もAC。いいですねー。
  * ちゃんと理解できた気がする。いいですねー。

## 3.2

[B12](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ck)

* (2024-04-07)
  * [ニュートン・ラフソン法](https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A5%E3%83%BC%E3%83%88%E3%83%B3%E6%B3%95)で解いてみるか
  * 少ないイテレーションで近似の精度が良かった記憶。N は1から10^5までなので、テスト全網羅できそう。
  * [AC!](https://atcoder.jp/contests/tessoku-book/submissions/52128014)。テストも書けてニッコリ。
  * イテレーション10回だと全然足りなくて草。

## 3.3

[B13](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cl)

* (2024-04-07)
  * N=10^5 なので、商品を２重ループすると、もう間に合わないな。
  * セクションのタイトルがチラッと見えて「しゃくとり法」とあった。
  * どんなのだったかよく思い出せないけど、購入する商品の先頭の品番と末尾の品番を芋虫みたいにくねくね動かしていくやつだっけ？
  * [WA](https://atcoder.jp/contests/tessoku-book/submissions/52130930)で草。
  * 何かあかんねやろな（そらそう）
* (2024-04-09)
  * しゃくとり法。適当実装だったので、バグりまくる。
  * fuzzing test っぽくランダムな入力値を生成して、コードを試す。期待値を返さない入力値を見つけることに成功。
* (2024-04-10)
  * 自作のなんちゃってしゃくとり法だとやっぱり[WA](https://atcoder.jp/contests/tessoku-book/submissions/52225075)。
  * [けんちょん氏の記事](https://qiita.com/drken/items/ecd1a472d3a0e7db8dce)で学ぶ。
  * 記事の見よう見まねでコードは書いてみたけど、腑に落ちてない。というかコードの動きが正確にわかっていない。
  * こりゃいかん、A問題の二の舞だ。時間を書けてちゃんと理解しよう。
* (2024-04-11)
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52231886)
  * しゃくとり法で詰まったところは[コメントに残した](https://github.com/toasa/tessoku-book/blob/main/13b.py#L10-L28)。

## 3.4

[A14](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_n)

* (2024-04-12)
  * 39/41はOK！ [惜しい！](https://atcoder.jp/contests/tessoku-book/submissions/52269129)
  * 自作の二分探索がバグってんのかな？
  * いや 39 行目があかん。box3_4 から探したいのは `x` やなくて、`target_int-x` や！
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52269535)。

[B14](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cm)

* (2024-04-11)
  * 全探索だと2^30で大体10^9ほどかかる。ので、TLE。
  * 側のコードだけ用意
* (2024-04-12)
  * うお！これA問題も解けてないやん...。
  * 諦めて教科書の解法みよう
  * 半分全列挙とな...

## 3.5

[A15](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_o)

* [解けた](https://atcoder.jp/contests/tessoku-book/submissions/52277899)。３章の知識は特に使ってない気がする。普通に hash map で解いた。
* ３章のテーマは二分探索か。何かしら二分探索を使えと..

# 4. 動的計画法

## 4.2 動的計画法の復元

[B17](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cp)

* (2024-04-15)
  * カエルが一つまたは二つ先の足場に移動するとき、移動コストの総和を最小にする問題。
  * 最小コストの計算は多分簡単にできそう。
  * だけど、その時の移動方法も答えないといけない。セクションタイトル通り「復元」がキモなのね。
  * いくつ前の足場から飛んできたかもメモに記録するようにした。
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52414777)。ぽやしみ~

## 4.3 二次元のDP(1) 部分和問題

[B18](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cq)

* (2024-04-16)
  * 解き方思い出せないなあ。
  * この問題は「部分和問題」という名前がつけられてる。典型的な問題なんだろう。
  * 問題の概要は以下：
    * N 枚のカードがあり、各カードには整数が書かれている。この時、合計が S となるようなカードの選び方は存在するか？
  * 教科書の解き方見る。
  * あー、DP用の二次元配列を作るのか...。ムズ。
    * `dp[i][j]`: カード 1, 2, ..., i の中から何枚か選び、その合計を j とすることができるか
* (2024-04-17)
  * 部分和問題、引き続きやっていきます。
  * やっぱり、DP の配列の作り方と、中身の更新方法はむずいよな。
  * 具体例で考えてみる。
  * カードが `2`, `5`, `3`, `8`, `1` の５枚、合計値 `9` とする。
  * DP 配列の更新は、各行を以下のように更新していく（新しく埋まったマスは `N` を、以前の行の結果を利用したマスは `*` を記した）：
    * ```
         | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
      ---+---+---+---+---+---+---+---+---+---+
       2 |   | N |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       5 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       3 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       8 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       1 |   |   |   |   |   |   |   |   |   |
      ----------------------------------------
      ```
    * ```
         | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
      ---+---+---+---+---+---+---+---+---+---+
       2 |   | * |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       5 |   | * |   |   | N |   | N |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       3 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       8 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       1 |   |   |   |   |   |   |   |   |   |
      ----------------------------------------
      ```
    * ```
         | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
      ---+---+---+---+---+---+---+---+---+---+
       2 |   | * |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       5 |   | * |   |   | * |   | * |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       3 |   | * | N |   |*/N|   | * | N |   |
      ---+---+---+---+---+---+---+---+---+---+
       8 |   |   |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       1 |   |   |   |   |   |   |   |   |   |
      ----------------------------------------
      ```
    * ```
         | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
      ---+---+---+---+---+---+---+---+---+---+
       2 |   | * |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       5 |   | * |   |   | * |   | * |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       3 |   | * | * |   | * |   | * | * |   |
      ---+---+---+---+---+---+---+---+---+---+
       8 |   | * | * |   | * |   | * |*/N|   |
      ---+---+---+---+---+---+---+---+---+---+
       1 |   |   |   |   |   |   |   |   |   |
      ----------------------------------------
      ```
    * ```
         | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
      ---+---+---+---+---+---+---+---+---+---+
       2 |   | * |   |   |   |   |   |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       5 |   | * |   |   | * |   | * |   |   |
      ---+---+---+---+---+---+---+---+---+---+
       3 |   | * | * |   | * |   | * | * |   |
      ---+---+---+---+---+---+---+---+---+---+
       8 |   | * | * |   | * |   | * | * |   |
      ---+---+---+---+---+---+---+---+---+---+
       1 | N | * |*/N| N | * | N |*/N|*/N| N |
      ----------------------------------------
      ```
  * [実装した](https://atcoder.jp/contests/tessoku-book/submissions/52449809)。結果は大体良さそうだけど RE がいくつか。
  * 原因は、エッジケースの index out of range が怪しくはある。
  * N==1 の場合のテストケースが抜けてたので足してみる。
    * => これじゃないっぽい。
  * ファジングテストを試してみる。
  * [これの](https://atcoder.jp/contests/tessoku-book/submissions/52449809)11 行目で index out of range起きてた。確かに一枚目が期待する合計値を超えるケースもあるか。
  * 無事 [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52450331)。
  * 自分が思いつくテストケースだと、バグが取れないこともあるので、ランダムな入力を食わせるテストは有用だな。
  * 少なくとも Atcoder で結果が RE の場合は、考慮できてないテストケースがあるはずなので、ファジングテストを試せるようにしよう。

## 4.4 二次元のDP(2) ナップザック問題

[B19](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cr)

* (2024-04-17)
  * DP の難しさをまとめる
    1. DP 用の配列を考える難しさ。問題の変数のうち、一つを配列の要素とし、残りを配列のインデックスにする。
    2. DP 用の配列を更新する難しさ。以前の結果をうまく使い、配列の行を埋めていく。
  * 1\. の問題の制約も良いヒントになりそう。ある変数の最大値が `10^9` の場合、その変数をDP配列の要素にするのは無理筋。行 or 列を舐めるのが間に合わない。
* (2024-04-18)
  * `dp[i][j]` を、重量 `j` 以下の制約で、商品 1, 2,..., `i` の中からいくつか選んだ場合の価値の最大値。
  * ↑の作り方だと `dp[N][W]` がそのまま答えになるので、良さそうなんだけど、今回 `W`（ナップザックの容量）の最大値が `10^9` なんだよな...
  * 配列のインデックスを別の変数にすれば良いのか
  * 商品の価値は最大でも `10^3` なのでこれか。
  * つまり `dp[i][j]` を、商品 1, 2, ..., `i` の中からいくつか選ぶ場合の商品の**価値**の合計が `j` 以下となるような最小の容量、とする。
  * うーん、わからん。[@drken 氏の解説記事](https://qiita.com/drken/items/dc53c683d6de8aeacf5a#e-%E5%95%8F%E9%A1%8C---knapsack-2)を見る。
  * DP 配列のインデックスが変わるだけでこんなむずかしいとは！
* (2024-04-20)
  * ちゃんとわかってない。DP 配列の定義が少し間違ってそう。正しいと思う定義は以下：
  * `dp[i][j]`：商品 1 から i までの中からいくつか選ぶとき、総価値が j **以上** となる選び方のうち、最小の総重量
  * これだと良さそう。DP配列の更新作業は、各 i に対して、価値を降順に見ていけば良さそう。（要素の初期値は重量無限大のシンボルをつけておく）
  * [AC できたー](https://atcoder.jp/contests/tessoku-book/submissions/52527903)🎉
  * DP 配列の作り方を再度まとめてみる。
    1. 問題文の指標をすべて列挙する。
        * 今回なら「重さ」、「価値」、「商品番号」
    2. それらの指標のうち、どれをDP配列の要素に選び、残りをインデックスにするか決める。
        * 普通の DP 問題だと `DP[n_items][weight_limit]` みたいに、答えが $\mathcal{O}(1)$ で求まるようにインデックスを決めれば良さげ。ただ、今回のように、重量の最大値が 10^9 になると、配列のインデックスにはできなくなる。
    3. 良い感じで DP 配列を更新していく。

## 4.5 二次元のDP(3) 最長共通部分列問題

[B20](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cs)

* (2024-04-20)
  * で、出たー！レーベンシュタイン距離ー！
  * さて、どうやるんだっけ...orz
* (2024-04-21)
  * 文字列 `S`, `T` に対して DP 用の二次元配列を考える。
  * 縦横のサイズは `len(S)+1`, `len(T)+1`。
  * `dp[i][j]` は、部分文字列 `S[:i]` と `T[:j]` のレーベンシュタイン距離（L距離）を格納することにする。
  * 空文字と n 文字の文字列とのL距離は n（n 回の文字挿入操作があるため）。
  * うーん、更新方法がわからんな。
  * 記憶だと `dp[i][j]` を埋める際は、以下の要素を参照するはず：
    1. `dp[i][j-1]`
    2. `dp[i-1][j]`
    3. `dp[i-1][j-1]`
  * 1\. と 2\. の場合は理解できる。今見ている文字列のどちらかが１文字少ない場合の L距離を参照してるんだから、そこから１文字挿入、または削除した結果として埋めれるよね、というアイデア。
  * 3\. の場合が、多分置換操作に対応するんだろうけど。なぜ置換になるのかわからんな。
  * 例えば "foo" と "fizz" のL距離を考える時に、"fo" と "fiz" のL距離からどう考えたら置換になるんだろ。
  * あー、一般的に考えたらわかりやすいかも。
  * "XX...XXx" と "YY...YYy" の L距離を求めたい場合に、x から y への置換を考えれば良いのか。
    * x==y の場合、置換要らないので "XX...XX" と "YY...YY" のL距離を引き継ぐ
    * x!=y の場合、置換必要なので、"XX...XX" と "YY...YY" のL距離 + 1 のコストがかかる。
  * こんな感じ？
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52635042)

## 4.6 二次元のDP(4) 区間DP

[B21](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_ct)

* (2024-04-21)
  * `dp[i][j]` ：文字列 `S` の部分文字列 `S[i:j]` に対し操作を施した場合に作成できる回文のうち、その回文の最長の長さ
  * i, j は inclusive な index とする。例えば S=bar で `dp[1][1]` は 'a' を考えることとする。
  * 1文字は明らかに回文なので、`dp[i][i]` は 1 になる。
  * 部分文字列を考慮するので i < j とする。つまり DP 配列は上三角行列を考える。
* (2024-04-23)
  * DP 配列の更新を考える。
  * `dp[i][j]` は `dp[i][j-1]` と `dp[i+1][j]` を参照すればよさそう。
  * 部分文字列 "aXXXb" を考える。"aXXX" の結果は `dp[i][j-1]` を見れば良く、"XXXb" の結果は `dp[i+1][j]` を見れば良い。"aXXX" の右端に "b" を追加すれば今考えてる文字列になる。"b"を追加して、回文になる場合とならない場合があり、それは文字列の左端を調べればわかる。"XXXb" の左端に "a" を追加する場合は、右端を調べて回文になるかチェックすれば良い。
  * "abcb" の場合にDP配列がどうなるか考えてみよう
    * ```
         | a | b | c | b |
      ---+---+---+---+---+
       a | 1 |   |   |   |
      ---+---+---+---+---+
       b | - | 1 |   |   |
      ---+---+---+---+---+
       c | - | - | 1 |   |
      ---+---+---+---+---+
       b | - | - | - | 1 |
      ---+---+---+---+---+
      ```
    * ```
         | a | b | c | b |
      ---+---+---+---+---+
       a | 1 | 1 |   |   |
      ---+---+---+---+---+
       b | - | 1 | 1 |   |
      ---+---+---+---+---+
       c | - | - | 1 | 1 |
      ---+---+---+---+---+
       b | - | - | - | 1 |
      ---+---+---+---+---+
      ```
    * ```
         | a | b | c | b |
      ---+---+---+---+---+
       a | 1 | 1 | 1 |   |
      ---+---+---+---+---+
       b | - | 1 | 1 | 3 |
      ---+---+---+---+---+
       c | - | - | 1 | 1 |
      ---+---+---+---+---+
       b | - | - | - | 1 |
      ---+---+---+---+---+
      ```
    * ```
         | a | b | c | b |
      ---+---+---+---+---+
       a | 1 | 1 | 1 | 3 |
      ---+---+---+---+---+
       b | - | 1 | 1 | 3 |
      ---+---+---+---+---+
       c | - | - | 1 | 1 |
      ---+---+---+---+---+
       b | - | - | - | 1 |
      ---+---+---+---+---+
      ```
  * あー、上で述べたDP更新方法は間違いかも。
  * 部分文字列が xSSSSy に対し、`dp[i][j]` の値は以下のように更新すべきだと思う：
    * x==y の場合は左下の結果 (`dp[i+1][j-1]`) +2
    * x!=y の場合は max(左の結果(`dp[i][j-1]`)、下の結果(`dp[i+1][j]`))
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52728568)! Foo!

## 4.8 ビットDP

[A23](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_w)

* (2024-04-24)
  * クーポンの枚数が最大100枚なので、全探索は無理っぽい
  * わからん。教科書見る。
  * 二次元DPを作るらしい。テクニカルだな
  * `dp[i][j]`：クーポン券 1, 2,..., i から何枚か選び、集合 j（商品の選び方をビット表現した整数値）にする場合の、選ぶクーポンの最小枚数。
* (2024-04-25)
  * DP 配列の更新方法を考える。
  * 今みている、クーポン i と商品集合 j に対し、一つ前の行、つまりクーポン i-1 の行の、どの列を参照すれば良いか？
  * クーポン i が適用できる商品集合と、j の商品集合との xor を取れば良いのでは？
  * 例えばクーポン i が 010 の商品をカバーし、今 110 の商品集合を見ている場合、010^110=100 のカラムを見れば良い。
  * 未来の自分のために以下のテストケースのDP配列を載せておく：
    * ```
      3 4
      1 0 0
      0 1 0
      0 0 1
      1 1 0
      ```
    * <img src="https://i.imgur.com/Mq0fmRf.jpg" width="500">
  * 自信満々で提出したら [WA 出てて](https://atcoder.jp/contests/tessoku-book/submissions/52763584)草。
  * コーナーケースのテストを足してみる。
  * n_item=1 の場合、または n_coupon が=1 の場合は問題なさそう。
  * ファジングテストやりますか...。
  * あー、print デバグしてみやすいように INF の値をめっちゃ小さくしてたんだった...。
  * INF を十分大きくして無事 [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52781904)。

[B23](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_cv)

* (2024-04-26)
  * 全然わからんので教科書のヒント見る。
  * `dp[通った都市][今いる都市]` を考えれば良いらしい。
  * うーん、よくわからん。
  * 「巡回セールスマン問題 DP」でググって Qiita の記事見つけた。
  * DP 配列の説明がちょっと違う。`dp[訪れた都市の集合][最後に訪れた都市]` とする。
  * つまり都市数が４つで、既に 0,1,2 を訪れて、最後に訪れたのが 2 とすると `dp[{0,1,2}][2]` となる。
  * [algo-logic.info](https://algo-logic.info/bit-dp/#)の記事も見る。
* (2024-04-27)
  * [algo-logic](https://algo-logic.info/bit-dp/) の記事で DP 配列の定義を再度確認：
    * $dp[S][v]$ : 都市 $\{0, 1, 2, ..., n-1\}$ の部分集合 $S$ を巡回する $S!$ 通りの経路のうち最短のものの距離。ただし、$v\in S$ かつ、最後に頂点 $v$ に到達した場合のみを考える。
  * DP の更新方法はこうかな？：
    * $dp[S][v] = \underset{u\in S}\min\{dp[S][u] + \textrm{dist} (u,v)\}$
  * 答えみる。ちょっと違う。$v$ を追加する集合を考えないと。：
    * $dp[S\cup \{v\}][v] = \underset{u\in S}\min\{dp[S][u] + \textrm{dist} (u,v)\}$
  * 実装してみたが、開始地点に戻ってくることを考慮できていない。
  * algo-logic の記事を再度確認。DP 配列の定義に「都市 0 から始める」という制約を加えてた。確かにどの都市も一回は通るので始点を固定すれば良い：
    * $dp[S][v]$ : **都市 $0$ からスタートして** 、都市 $\{0, 1, 2, ..., n-1\}$ の部分集合 $S$ を巡回する $S!$ 通りの経路のうち最短のものの距離。ただし、$v\in S$ かつ、最後に頂点 $v$ に到達した場合のみを考える。
* (2024-04-28)
  * ようやく DP 配列の行の意味が納得できた。
  * コメントにも残したけど、以下：
  ```
  dp[S][v]: 都市 0 からスタートし、都市 {0,1,...,n-1} の部分集合 S を巡回する経路の内、移動距離の最小値。
            ただし、都市 v を最後に訪れたものとする。 また、最初に都市 0 にいることを S の lsb で表現しない。
            たとえば、都市の数が３の場合、以下のようになる：
  
    * S = 0b010 の場合、移動 0->1 を表す。
    * S = 0b100 の場合、移動 0->2 を表す。
    * S = 0b110 の場合、移動 0->1->2, または 0->2->1 を表す。
    * S = 0b111 の場合、移動 0->1->2->0, または 0->2->1->0 を表す。

  よって、DP[0b111][0] を見れば、0 へ帰る
  ```
  * なので最後に `DP[0b11...11][0]` を見れば答えになる。
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/52900909)🎉

## 4.9 最長増加部分列問題

[A24](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_x)

* (2024-04-30)
  * わからん。教科書見る。
  * `dp[i]` を「最後の要素が $A_i$ である部分列のうち、最長のものの長さ」とする。
  * `L[x]` を「長さ $x$ の増加部分列の最後の値の中で最小値」
* (2024-05-01)
  * セグメント木を使うと `dp[i]` の計算が $\mathcal{O} (\log N)$ でできるらしい。セグメント木のクエリ操作を再帰関数で書いてみる：
    * https://github.com/toasa/tessoku-book/blob/main/toybox/segment_tree2.py
  * むずい。わからん。飛ばす。

# 5. 数学的問題

## 5.5 余りの計算 (3)：割り算

[B30](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dc)

* (2024-05-02)
  * コンビネーション $_n \mathrm{C}_r$ の計算には割り算が出てくる。割り算は MOD 演算で閉じてないので、計算を工夫する必要がある。
  * 教科書 p.174「$p$ を素数とし、$a$ を $p$ と互いに素な整数とする。このとき、$p$ で割った余りを求める問題では /$a$ の結果と * $a^{p-2}$ の結果は等価になる。
  * この結果は、フェルマーの小定理（$a^{p-1}=1$）より従う。
  * 確かに a で２回割れば従いそうではある：
    * $a^p = a$
    * $a^{p-1} = 1$
    * $a^{p-2} = 1/a$

## 5.7 ゲーム（１）：必勝法

[B32](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_de)

* (2024-05-03)
  * DP っぽく解けば簡単だった。
  * `dp[i]`: のこり i 枚で自分のターンの場合の勝敗。False は負け。
  * 自分が手札を引くことで相手に必敗手番を渡せれば、自分は必勝。

## 5.8 ゲーム（２）：ニム

[B33](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_df)

* (2024-05-03)
  * 駒が左上隅に来て動かせなくなったら負け、という理解。
  * テストケースをメモ帳に書き、コマを動かしてみる。
  * コマが対角線上にあるときは負け、それ以外は勝ち、かな：
  * 書いてみたが WA:
    * https://atcoder.jp/contests/tessoku-book/submissions/53040717
  * わからん。一旦飛ばす。

# 6. 考察テクニック

## 6.2

[B37](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dj)

* (2024-05-06)
  * 整数 $n$ に対し、$f(n)$ を $n$ の各桁の和とする。例えば $f(738)$なら $7+3+8=18$ となる。
  * この時、与えられた $N$ に対し、$f(1)+f(2)+...+f(N)$ を求める問題。
  * 以下の２パターンに分けて、考えると良さそう。
    1. 1の位
    1. 10 以上の位
* (2024-05-08)
  * なかなか解けんな、この問題。
  * １の位とそれ以外の位の2パターンに分けるのではなく、各桁について1,2,3,...の数を数え上げていく。
    * https://wandbox.org/permlink/zhpGhv7K0Thktngv
  * 気合いで規則性を見つける。
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/53250580)。

## 6.3

[B38](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dk)

* (2024-05-11)
  * max の長さを求めてみるってのはどう？
  * 上限値を考えてみる
  * わからなかったので友人に相談。草をノード、高低を辺のDAGを考えると、草をタイプ分けできるとのこと。賢い！
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/53372677)

## 6.4 一手先を考える

[A39](https://atcoder.jp/contests/tessoku-book/tasks/math_and_algorithm_bn)

区間スケジューリング問題。
数時間考えて、やり方浮かばず。
チラッと答え見て「貪欲法」と知る。
何かうまくソートすれば良いとは思ったが、映画の上演時間順でソートすることしか試せなかった。
しばらく悩んだため、「区間スケジューリング問題」でググってみて、解答を知る。
終了時間でソートすれば良いとは！

終了時間でソートするだけで良いのか少し考える。
終了時間が同じで開始時間が異なる映画が２つあった場合、どちらを選んでも、
次に選ぶ映画の選び方には影響しない
（次の映画の開始時間が前の映画の終了時間より前なら選ばないし、後なら選ぶだけなので）。
よって終了時間でソートするだけで問題なさそう。

[B39](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dl)

* (2024-05-12)
  * どの仕事をすべきか、という戦略を立てる。
  * 先行して終わらせられる仕事は、先にやってしまった方が良さそう。なぜなら、先に終わらせることで、後発の仕事を選ぶ際の選択肢が増えるから。
  * なので、まず給料の順にソートして、次に開始日について安定ソートした上で、各日に対して最も給料が高い仕事を選んで行けば良さそう。
  * あー、それだとうまくいかないのか。[テストケース](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dl)の状況で、４日目に給料2円の仕事5を選んでしまう（給料3円の仕事3を選ぶべき）。
  * なので、以下の方法にしてみるか
    1. 開始日早い順にソート
    2. 給料高い順に安定ソート
  * うーん、上手くいかんな。
  * 給料順に取り出せる Priority Queue を使ってみる。
  * 競プロ＆Python3 で Priority Queue を使いたい場合、queue.PriorityQueue ではなく、[heapq を使え](https://qiita.com/recuraki/items/7f7c786770b3c3daa8f5)とのこと。
  * 給料が高い仕事を選びたいので、max-heap を使いたい。Python3 の heapq は min-heap なので、値を x-1 して heappush し、heappop した値を x-1 することにする。
  * 以下のように実装：
    1. 開始日が早い順に仕事をソート
    2. 各日をイテレート。その日から始められる仕事は、全てPriority Queue に push する。各日に対して最も給料が高い仕事を選ぶ（heappop）。
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/53410607)。

## 6.5 個数を数える

[B40](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dm)

* (2024-05-12)
  * 数を mod 100 で考えて、それぞれ何個あるかカウント。
  * 例えば mod2 の数が 2個、mod98 の数が3個なら、掛けて6通りの組み合わせになる。
  * 0 と 50 だけ例外処理。
  * [AC](https://atcoder.jp/contests/tessoku-book/submissions/53417835)

## 6.6 後ろから考える

初見ではどうするねんとなり、
とりあえずテストケースを思いつくだけ書いてみる。
しばらくして「結局左右どちらかの端がXXXになってれば良さげ」という結論を朝出した。
お昼休憩中に RBRRRBR も出来ることに気づき、嬉しかった。
結局思いついた複雑なパターンは、３連タイルを使うことで、
最後から１つ前の塗り替えまでは到達できる気がしてきた。
それをそのまま実装し（最初から連続３タイル分を見ていき、全部同じ色だったら塗り可能）て無事AC。

[B41](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_dn)

* (2024-05-13)
  * "Reverse of Euclid" 良いタイトル！
  * その名の通りユークリッドの互除法を逆順にたどる問題。

## 6.7 固定して全探索

* 難易度星４つ。自力で解けたらテンション上がりますなこりゃ。
* 体力、気力それぞれでソートするのは必要だろうなあ。K以内という条件が２つの指標に課されるのがむずかしポイントですわ。
* 仮に体力だけだと、問題は簡単そう。幸い体力の上限値が100なので、体力0からiまでの人数をカウントする累積和の配列を作って、幅 K で配列をスライドして見てけば、max が求められる。
* 累積和の問題は、誰がカウントされてるか、という情報が抜け落ちちゃうこと。
* 解けた。が、解法として全然綺麗じゃない気がする。自分の解法は以下：
  * 生徒を体力順でソートした配列と、気力順でソートした配列を用意する。
  * 体力順の先頭から生徒をイテレートし、（当該生徒の体力+K）以内の体力を持つすべての生徒をリストアップする。
  * 体力順の各イテレートの中で、気力順の生徒のイテレートを行う。つまり２重ループ。気力も同様に、（当該生徒の気力+K）以内の気力を持つすべての生徒をリストアップする。
  * 体力でリストアップした生徒群と気力でリストアップした生徒群の共通部分を求め、その長さを最大値かチェックする。
* 朝問題を見て、解けたのは夕方。綺麗な解法じゃないと思いつつ、コードを書いてく。よっこらしょという感じ。

[B42](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_do)

* (2024-05-14)
  * カードの（表、裏）に対して、以下４パターンでソートし、1枚目、1,2 枚目、1,2,3 枚目,... というように選んでみる：
    * (昇順、昇順)
    * (昇順、降順)
    * (降順、昇順)
    * (降順、降順)
  * テストケース "random large" で [WA](https://atcoder.jp/contests/tessoku-book/submissions/53444075)。
  * 「固定して全探索」ってなんだっけ？
  * A42 でいう、体力aと気力bを固定して、N人を全探索する。a, b は 100 以下なので、(a,b) の組は 10^4 通り。
  * あー、B42 だと、以下の４通りに対してそれぞれ全探索をすれば良いのかも。
    1. 表が 0 以上の整数
    1. 表が 0 未満の整数
    1. 裏が 0 以上の整数
    1. 裏が 0 未満の整数
* (2024-05-16)
  * Fuzzing test で自分のコードで上手くいかないケースを見つける。
  * あー、以下の４パターンで考えれば良さそう：
    1. 表、裏どちらも正
    1. 表が正、裏が負
    1. 表が負、裏が正
    1. 表、裏どちらも負
* (2024-05-17)
  * 改めて解答方針をまとめる。
  * Score は abs(表の数字の総和) + abs(裏の数字の総和) で求まるので、二つの abs() の中身を正負どちらの方向に伸ばすか予め決める。二つの正負のパターンは以下の４通り：
    1. 表、裏どちらも正方向
    1. 表が正方向、裏が負方向
    1. 表が負方向、裏が正方向
    1. 表、裏どちらも負方向
  * 各パターンに対して、今見ているカードを選択すべきか $\mathcal{O}(1)$ で決めることができる。例えばカード [8/-3] の場合、各パターンに対するスコアは以下になる：
    1. 8 + (-3) = 5
    1. 8 + -(-3) = 13
    1. -8 + (-3) = -13
    1. -8 + -(-3) = -5
  * よって、パターン 1, 2 では総スコアを増やすので選択すべき。パターン 3, 4 では総スコアを減らすのでスキップすべき。

## 6.8 問題を言い換える

* 難易度星４つ。この辺だと初見ではどうすんねん、以外の感想が出てこないw
* 例によって、Nが小さい場合から考えていく。
* N==1 だと楽勝。誰ともぶつからないので。
* N==2 だと、ぶつかる場合が出てくる。ただし１パターンのみで、A1:E, A2:W の場合のみ。残り３パターンはすべてぶつからない。
* N==3 の場合も可能性を全列挙。ぶつからないパターン、１回ぶつかるパターン、２回ぶつかるパターンに分類。２回ぶつかるパターンでは、１回目のぶつかり直後は、１回ぶつかるパターンに帰着したとも見れる。ふーん。
* (2024-02-19)トンネル最終退出者のあたりをつけてみる作戦。
* (2024-02-20)最終退出者候補二人は初期位置で隣り合ってる、という仮説１。一つ隣の人の最終退出時間から自分の最終退出時間を（いわゆるDP的に）求められる、という仮説２。仮説１は手元で試したパターンだと正しそうなんだが、仮説２が怪しい。片方向だけのDPだと明らかに決まらないパターンがある。例えば人iが←、人i+1が→の場合、i+1の最終退出時間はiの情報だけでは決まらない。なので、左右両方向からDPの配列を埋めてくと良いのかと思った。しかし、例えば→→←の場合は両端の最終退出時間はわかんないよなあ。N==3 の場合をうまくいくようなアルゴリズムをもっと考えてみよう。
* (2024-02-23)右から左にdp 配列を（埋めれるとこだけ）埋め、次に左から右に埋める戦略は？
* (2024-02-24)答え見た。そのアイデアは全く浮かばなかった。完敗！

## 6.10 不変量に着目する

* 仮説「どんな2枚のカードの選び方をしても最終的なカードは変わらない」を立ててみる。パッと何パターンかみたところ正しいっぽい。
* 最終カードが選び方によらなそうなことがわかったので、青と赤の同枚数ペアは無視することに（白は何枚あっても白なんで、拝アンミカ）。あとは青、または赤の連続が何色になるかという問題になり、青青、青青青、青青青青、... と見てくと周期が見えた。無事AC。

# 8. データ構造とクエリ処理

## 8.1 スタック, 8.2 キュー

Python3 のスタック、キューの操作を問う問題。
競プロ界隈だと `collections.deque` を使うと知る：

https://qiita.com/saba/items/107c4237206e31acdbef

deque とは "Double-ended queue" の略語で、「デック」と発音するっぽい：

https://docs.python.org/ja/3/library/collections.html#collections.deque

## 8.6 文字列のハッシュ

[A56](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bd)

* 全クエリに対してナイーブに文字列比較すると余裕で TLE
* やはりテキストの前処理が必要かと理解。累積和を使って文字列の ascii 値の総和を事前に計算。クエリ処理時はまず総和を比較し、総和が異なっていたら early return みたいにした。だが、まだTLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50726648
* builtin の `hash()` 関数を使ってみることに。hash の計算自体も文字列全部を舐めるはずだから、クエリごとに計算してたら間に合わんよなーと薄々感じていた。案の定 TLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50726883
* (2024-03-01) 文字列比較の際、先頭からだけではなく後ろからも見てみる猪口才な工夫。無事TLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50732781
* (2024-03-01) 答えをチラ見。部分文字列のハッシュ値が $O(n^2)$ でなく、 $O(n)$ で計算できるように工夫するっぽい。
* (2024-03-02) ハッシュ関数としてB進法を知る。教科書では長さ n の文字列 S に対し、次のような定義だった： $\sum_{i=0}^{n-1} B^i S[n-(i+1)]$。 自分は $\sum_{i=0}^{n-1} B^i S[i]$ の方がシンプルで良さそうな気がしてた。が、自分のやつだと i 文字目までのハッシュから i+1 文字目までのハッシュを計算する際に $B^i$ を計算しないといけなくなる。これは重い。教科書の定義だと単に $B$ を１つ前のハッシュ値にかければ良いのでコストが低い。やっぱりこういうことも考慮されてるんだな。
* (2024-03-03) B 進法を使ったハッシュ計算を実装する。１）部分文字列のハッシュ値がマイナスになりうる点、２）ハッシュ値の事前計算が Off-by-one エラーになった点（空文字に対してもハッシュ値を定義し、一文字のハッシュ値をインデックス 1 に格納すべきだった）に苦しんだ。なんとかAC。疲れた。

## 8.7 ダブリング

[A57](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_be)

* (2024-03-04) 必ずしも綺麗なループになるとは限らんな。部分的なループになることもある 1->2->3->2 とか。
* (2024-03-05) タイトルになってるダブリングの競プロ的な意味を調べる：
  * https://zenn.dev/fjnkt98/articles/3c0c21778b6101
  * > 全体の要素数 $N$ 個に対し、それぞれの要素から１回遷移した移動先が与えられたとする。このとき、 $K$ 回遷移した時の到達点を高速に求めるアルゴリズムの１つ。ナイーブな方法だと $\mathcal{O}(K)$ だが、ダブリングだと $\mathcal{O}(N\log K)$ で計算できる。
* (2024-03-05) A57 の条件は $N\le 10^5$、$K\le 10^9$ で最大 $10^5$ 個のクエリに答えないといけない。 $\mathcal{O}(N\log K)$ だと間に合わなくないか？-> いやダブリングはクエリごとに計算するのではなく、事前計算らしい。なら大丈夫か。
* (2024-03-07) 解けたー。これは自力解答は無理だったな。ダブリングの名前の由来もわかった。DP配列に2の冪乗日後の結果を保存しておき、各クエリで問われる n 日後は繰り返し二乗法で求めれば良い。
* ついでに CPython と PyPy の比較もやってみる。 
  * PyPy: 実行時間254ms, メモリ128MBほど。
  * CPython: 実行時間1172ms, メモリ64MBほど。
  * A57 の制限は実行時間が2秒以内、メモリが1GB以内なので、CPython の実行時間が一番余裕がなさそう。まぁこれからは PyPy を使うか。
<img src="https://i.imgur.com/h8XVwCF.png" width="700">

## 8.8 セグメント木：RMQ

[A58](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bf)

* (2024-03-08)
  * ナイーブな実装ではクエリごとに区間の最大値を、配列をイテレーションすることで求める。これでた $\mathcal{O} (NQ)$ 最大 10^9 の計算量になるので間に合わない。
  * 最大値や最小値を素早く求めるというと、ヒープが思い浮かぶ。ただし、今回は配列全体ではなく、一部分の区間内の最大値が問われている。
  * 更新する値が最大 $10^9$ と結構大きいのは気になるよな。
  * 例によって自力回答は早々と諦め。教科書のセクションタイトルが「セグメント木」だったので、そのキーワードでググってみる。
  * [このページ](https://zenn.dev/magurofly/articles/3aa1084dfecce2)でリスト `L` に対し、ある範囲の全要素 `L[l]`, `L[l+1]`, ..., `L[r]` のモノイド積を $\mathcal{O}( \log N) $ で求められるらしい。
  * [モノイド積をおさらい](https://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%8E%E3%82%A4%E3%83%89)する。ある集合で閉じている二項演算で、結合律と単位元があれば良いらしい。
  * 確かに自然数に対する `max` もモノイド積なのか。
* (2024-03-10)
  * セグメント木のデータ構造を自作：
    * https://github.com/toasa/tessoku-book/blob/main/toybox/segment_tree.py
  * バグ取りは大変だったけど、実装はめっちゃ楽しかった。没頭できる感覚は嬉しい。プログラミング良いですな。

# 9. グラフアルゴリズム

## 9.1 グラフの実装方法

[A61](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bi)

* [これ](https://atcoder.jp/contests/tessoku-book/submissions/51204345)がダメで、[これ](https://atcoder.jp/contests/tessoku-book/submissions/51224325)が良い理由がよくわからない。
* 「出力の順序は問いません」ってあるので、隣接する頂点の表示順はなんでもいいってことだと思うけど。１個目と２個目の回答を比べると、結果をソートした以外に何が違うのかわからない。

## 9.2 深さ優先探索

[A62](https://atcoder.jp/contests/tessoku-book/tasks/math_and_algorithm_am)

* DFSはスタックでさあ。一発ACでござる。と思ったら[実行時エラー...](https://atcoder.jp/contests/tessoku-book/submissions/51228401)。RE は１つだけなので、コーナーケースが怪しそう。手元でいくつか試してみる。頂点が複数個で辺が少ない場合がどうもおかしい。
* 隣接する頂点がない場合 `adjs[i]` を `None` で埋めてたが、これが後の for ループで "'NoneType' object is not iterable" の実行時エラーを起こしてた。空リスト `list()` で埋めることで無事AC。
* DFS の計算量ってどうやって求めるんだろ。頂点の数 $N$ と辺の数 $M$ が関係するんだろうけど。
* @drken（けんちょん）さんの Qiita の記事みた。各頂点は１度しか通らず（到達したか否かを配列でメモしてる）、頂点に到達すると、その頂点から出る辺を全て調べる。ので計算量は $\mathcal{O} (N + M)$ とのこと。納得。
* あと、多重辺はないという問題の制約なので、隣接する点を管理する時にわざわざ集合 `set()` を使う必要なかった。リストで良さそう。

## 9.3 幅優先探索

[A63](https://atcoder.jp/contests/tessoku-book/tasks/math_and_algorithm_an)

* DFS だとどんどん深く潜り、頂点に到達した記録をつけてしまう。これだと別ルートの最短パスが仮にあっても、探索してくれない（すでに

## 9.4 ダイクストラ法

[A64](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bl)

* (2024-03-15)
  * なんという名前のアルゴリズムか思い出せなかった。人名なんだけどな。
  * 教科書のセクションタイトルで解決、ダイクストラさんでした。
  * このアルゴリズムのキモは、頂点を移動するか否かの判定の時に、BFS/DFS のような到達済みの boolean の配列で判定するのではなく、経路の最短距離をメモした配列を使って、最短距離が更新されそうなら頂点を移動する、という点だと思う。最短じゃないのに移動したら、その先の探索の最短経路の更新がおかしくなる。a->b まで移動して、次にa->b->cを探すときみたいな。
  * [REとTLE発生](https://atcoder.jp/contests/tessoku-book/submissions/51249117)！ぴえん。行数列数が頂点の数の二次元配列を作ってしまったが、これが大きすぎ？スタック溢れのエラーかしら。
* (2024-03-16)
  * RE はやはりメモリ使いすぎ問題だったっぽい。RE になったテストケースのメモリ使用量を見ると（[提出結果](https://atcoder.jp/contests/tessoku-book/submissions/51249117)のメモリのカラムから見れる）3596644 KB。これはメモリ制限の 1GB を超える。流石に確保しすぎなんだな。この辺の肌感覚が得られるのはありがたいところ。
  * TLE も3s制限を500msだけオーバーしてるんだよな。この二次元配列をやめたら、実行時間も早くなるのかね。
  * 実装自体に間違いはなさそうで。一安心。では手を動かしていきましょ。
  * 移動距離を格納するためのデータ構造として、何を使うか？二次元配列だとメモリのコストが高い。Python はタプルが Hashable だったので、`d[(v1,v2)]=move_cost` みたいな辞書に持たせた。
  * [無事AC](https://atcoder.jp/contests/tessoku-book/submissions/51255305)！実行時間は 3526 ms から 752 ms に、メモリは 3597596 KB から 182768 KB に低下。劇的な効果で草。

## 9.5

[A65](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bm)

* (2024-03-17)
  * 一発ACかと思ったら、[REのテストケースがあった](https://atcoder.jp/contests/tessoku-book/submissions/51357867)。メモリ食べ過ぎじゃないので、コーナーケースによる Python3 側のランタイムエラーかね。
  * ひょっとして、上司と部下の関係が循環参照になってるケースかね。社員 `i` が社員 `j` の部下であることを `i->j` と表すとすると、例えば `N==4` で `4->1`, `2->3`, `3->2` の場合の社員 `2`, `3` みたいな。
  * `2->3->2` みたいな上下関係の閉路が存在するとすると、部下の数はどうカウントしたほうがいいんだろ。`2->3->2` なら部下は一人づつで、`2->3->4->2` なら部下は二人づつが妥当かね。問題文の「部下」の定義を見直すとそれで良さそう。
  * とすると、社長（社員1）をルートとする通常の木構造と、その木構造から非連結な上下関係の閉路をカウントすれば良いのか（通常の木構造の中に閉路が現れることはない）。
  * あー、`2->3->4->2` と `5->2` みたいな、閉路に合流するパスが存在するケースもありえるのか。
  * 疲れてる、頭が回らない。
  * 最初にリーフノードを全てまとめて、各リーフノードから上に上がっていくか。それだと、閉路もなんとかできる気がする。
* (2024-03-19)
  * テストケースが１つREで失敗する件のつづき。
  * 原因は、ルートから到達できないノードが存在して、そのノードが Python の辞書に登録されてないことにより、参照したときに実行時エラー、かと思っていた。なので、到達できないノードには `0` を持たせてみた（[これ](https://atcoder.jp/contests/tessoku-book/submissions/51432158)の47行目）。だが、まだRE。
  * ということは、何か問題文の条件に読解ミスがあるのかもな。
  * あー、インデックス合わせで `bosses = [-1, -1] + bosses` と書いてたが、これはダメだわ。
  * [最初に出したコード](https://atcoder.jp/contests/tessoku-book/submissions/51357867)に戻ってきたでござる。
  * PyPy だけでなく、CPython でも[試してみる](https://atcoder.jp/contests/tessoku-book/submissions/51450477)。00.txt のRE変わらず。
  * REの原因なんなんだろ。
  * 再帰のしすぎでスタックあふれとか？
* (2024-03-20)
  * 再帰はやめて、スタックを使うことにする。
  * [実装した](https://atcoder.jp/contests/tessoku-book/submissions/51456593)。結果はTLE。
  * RE は無くなったし、TLE の原因はわかっている。19行目のループで同じノードを何度もイテレートしてしまう可能性があるため。
  * まぁ、一歩進んだと捉えて、考えましょか。
  * 木を walk する中で、一回目の訪問と二回目の訪問でやることを分けた。これで子供をイテレートするループが何度も回ることを避けた。
  * [無事AC](https://atcoder.jp/contests/tessoku-book/submissions/51459223)！くぅ~。

## 9.6

[A66](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bn)

* (2024-03-20)
  * ペロッ...これは、Union Find!
  * 吉祥寺のジュンク堂で『[アルゴリズムとデータ構造](https://www.amazon.co.jp/%E5%95%8F%E9%A1%8C%E8%A7%A3%E6%B1%BA%E5%8A%9B%E3%82%92%E9%8D%9B%E3%81%88%E3%82%8B-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E3%81%A8%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0-KS%E6%83%85%E5%A0%B1%E7%A7%91%E5%AD%A6%E5%B0%82%E9%96%80%E6%9B%B8-%E5%A4%A7%E6%A7%BB-%E5%85%BC%E8%B3%87/dp/4065128447)』を読んで実装方法を知る。
  * 本では "union by size" という最適化も紹介されていた。２つのルートノードの繋げ方として、子供の数が少ない方を多い方に繋げる、という最適化。
  * [それっぽく実装してみた](https://atcoder.jp/contests/tessoku-book/submissions/51463727)が、TLE ...。
  * 何か実装ミスったかな
  * なんか、木の深さを高々１にする最適化もあったような。つまりルートノードが全ての子供を抱え込むやつ。試してみるか。
  * [実装してみた](https://atcoder.jp/contests/tessoku-book/submissions/51466519)。07.txt が TLE なのは変わらず...
  * 各ノードの親をルートにすげ替えるやつ、『アルゴリズムとデータ構造』では経路圧縮という名前で紹介されてた。
  * 本では再帰関数で実装されてたので真似てみる。
  * [RE...](https://atcoder.jp/contests/tessoku-book/submissions/51468135)。スタック溢れかなあ。
  * これ C++ だとACになったりしないかな。07.txt が [127ms だけオーバー](https://atcoder.jp/contests/tessoku-book/submissions/51466519)なので、十分ありえそうで嫌だな。
  * [Pythonで競プロをするときの注意点まとめ](https://qiita.com/kemuniku/items/1f1537e1df2ac8180d9b)を読む。現時点で役立ちそうなこと：
    * PyPyの再帰関数は遅い（知らんがな(´・ω・`)）
      * 対策は CPython で提出する。
    * 再帰関数の深さの上限がデフォルトでは 1000（少ないw）
      * 対策は上限を増やす：
      * ```
        import sys
        sys.setrecursionlimit(10**7)
        ```
  * `sys.setrecursionlimit`を設定して[再提出](https://atcoder.jp/contests/tessoku-book/submissions/51470448)。RE が TLE になったでござる。
  * C++ の出番です。
* (2024-03-21)
  * [書いた](https://atcoder.jp/contests/tessoku-book/submissions/51480067)。07.txt は TLE で草。union by size の実装ミスなのかな？
  * 経路圧縮も試そうず。
  * [書いた](https://atcoder.jp/contests/tessoku-book/submissions/51480216)が、ちょびっと時間オーバーだし、なんなら1GBのメモリ使用上限オーバーでもある...
  * 『アルゴリズムとデータ構造』のコード例では、経路圧縮と union by size のどちらも適用したコードが載ってるな。確かにどちらか一方だけを選ぶ必要もないか。why not both?
  * [両方適用](https://atcoder.jp/contests/tessoku-book/submissions/51480344)。RE と TLE...
  * 教科書の github ページに Python3 での解答があり。薄目で見てみる。
  * ああ。`unite` の実装ミスってるな。２つのノードのルートが同じ場合は、くっつける必要ないわ...
  * [無事AC](https://atcoder.jp/contests/tessoku-book/submissions/51491997)。はぁ...。

## 9.7

[A67](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bo)

* (2024-03-22)
  * 最小全域木ってなんだっけ？
  * [Wiki](https://en.wikipedia.org/wiki/Minimum_spanning_tree)読む
  * 重みあり、向きなしグラフに対して、全ての頂点に到達するような辺の集まりの中で、トータルの重みが最小になる木だった。木なので閉路はない。
* (2024-03-23)
  * 『アルゴリズムとデータ構造』で最小全域木問題の概要把握。
  * ふむふむ、辺の重みでソートして貪欲法で解けるのか。理由は全然わかってないけど。
  * 実装的には、重みが小さい辺から見ていって、その辺が閉路を形成するならスキップする。
  * 閉路の検出はどうやるんだろ？
  * 本見る。Union Find を使うらしい。
  * Union Find をうまく使うと閉路を検出できる？
  * あー、以下のように使うのかも
    1. 別ルートなら、連結しても Cycle にならない
    2. 同ルートなら、連結すると Cycle が発生する（たぶん）
  * [AC~](https://atcoder.jp/contests/tessoku-book/submissions/51525449)。Union Find を使おうと思いついた人すごいな。エレガントやな〜。

## 9.8

[A68](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bp)

* (2024-03-23)
  * まず問題の意味がピンと来てない...。タンク1からNまで最大何 L/sec 流せるか?
  * ああ、パイプはそれぞれ太さが違ってて、流せる流量が違うのか。サンプルのテストケースの答えが 8 になるのも理解。
  * 解答の方針を立てた。先頭ノードから終端ノードに向かって、経路を全て辿る。辿る途中で現時点の最大流量は保持しておく。
  * これで行けそう。
* (2024-03-24)
  * うーん、やりたいことはぼんやりとわかってるつもりだが、実装がうまくできたい。
  * 難易度星６だし諦めるか。
  * 『アルゴリズムとデータ構造』第 16 章グラフ（４）：ネットワークフローを読んでみる。
* (2024-03-26)
  * そもそも問題を勘違いしてた。
  * あるノードに対して、例えば、入ってくるパイプは１本、出ていくパイプは２本だった場合、入ってきた水を余すことなく２本のパイプに流さないといけない。つまり、どちらにどれぐらい流すかも決めなければならない。
* (2024-03-27)
  * 『アルゴリズムとデータ構造』読む。
  * 専門用語が複数出てくる。(S,T) カット、(S,T) カットに関するカットセット、(S,T) カットの容量 (capacity)。辺連結度、辺素。
* (2024-03-30)
  * フォード・ファルカーソン法の手順をなんとなく理解する。面白いのは貪欲法ではあるんだけど、貪欲法で一つパス（フロー）を選ぶごとに、逆向きのパスを考えて更新していくところ。まぁ自力解答は絶対無理だったなw
  * 理解してないことは、その方法で最適解が求まる理由。まぁ厳密に理解しようとすると疲れちゃうし、今はふんわり理解のまま行こうかな。
  * 実装楽しみ。
  * [通したぞー](https://atcoder.jp/contests/tessoku-book/submissions/51794382)

## 9.9

[A69](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_bq)

* (2024-03-31)
  * 両者のマッチンググラフに、始点と終点を加えることで、フォードファルカーソン法を使えるらしい。教科書で知った。
  * [実装](https://atcoder.jp/contests/tessoku-book/submissions/51894904)。WAでさぁ。