https://www.amazon.co.jp/%E7%AB%B6%E6%8A%80%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AE%E9%89%84%E5%89%87-%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0%E5%8A%9B%E3%81%A8%E6%80%9D%E8%80%83%E5%8A%9B%E3%82%92%E9%AB%98%E3%82%81%E3%82%8B77%E3%81%AE%E6%8A%80%E8%A1%93-Compass-Books%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E7%B1%B3%E7%94%B0/dp/483997750X

# 6. 考察テクニック

## 6.4 

区間スケジューリング問題。
数時間考えて、やり方浮かばず。
チラッと答え見て「貪欲法」と知る。
何かうまくソートすれば良いとは思ったが、映画の上演時間順でソートすることしか試せなかった。
しばらく悩んだため、「区間スケジューリング問題」でググってみて、解答を知る。
終了時間でソートすれば良いとは！

終了時間でソートするだけで良いのか少し考える。
終了時間が同じで開始時間が異なる映画が２つあった場合、どちらを選んでも、
次に選ぶ映画の選び方には影響しない
（次の映画の開始時間が前の映画の終了時間より前なら選ばないし、後なら選ぶだけなので）。
よって終了時間でソートするだけで問題なさそう。

## 6.6

初見ではどうするねんとなり、
とりあえずテストケースを思いつくだけ書いてみる。
しばらくして「結局左右どちらかの端がXXXになってれば良さげ」という結論を朝出した。
お昼休憩中に RBRRRBR も出来ることに気づき、嬉しかった。
結局思いついた複雑なパターンは、３連タイルを使うことで、
最後から１つ前の塗り替えまでは到達できる気がしてきた。
それをそのまま実装し（最初から連続３タイル分を見ていき、全部同じ色だったら塗り可能）て無事AC。

## 6.7

* 難易度星４つ。自力で解けたらテンション上がりますなこりゃ。
* 体力、気力それぞれでソートするのは必要だろうなあ。K以内という条件が２つの指標に課されるのがむずかしポイントですわ。
* 仮に体力だけだと、問題は簡単そう。幸い体力の上限値が100なので、体力0からiまでの人数をカウントする累積和の配列を作って、幅 K で配列をスライドして見てけば、max が求められる。
* 累積和の問題は、誰がカウントされてるか、という情報が抜け落ちちゃうこと。
* 解けた。が、解法として全然綺麗じゃない気がする。自分の解法は以下：
  * 生徒を体力順でソートした配列と、気力順でソートした配列を用意する。
  * 体力順の先頭から生徒をイテレートし、（当該生徒の体力+K）以内の体力を持つすべての生徒をリストアップする。
  * 体力順の各イテレートの中で、気力順の生徒のイテレートを行う。つまり２重ループ。気力も同様に、（当該生徒の気力+K）以内の気力を持つすべての生徒をリストアップする。
  * 体力でリストアップした生徒群と気力でリストアップした生徒群の共通部分を求め、その長さを最大値かチェックする。
* 朝問題を見て、解けたのは夕方。綺麗な解法じゃないと思いつつ、コードを書いてく。よっこらしょという感じ。

## 6.8

* 難易度星４つ。この辺だと初見ではどうすんねん、以外の感想が出てこないw
* 例によって、Nが小さい場合から考えていく。
* N==1 だと楽勝。誰ともぶつからないので。
* N==2 だと、ぶつかる場合が出てくる。ただし１パターンのみで、A1:E, A2:W の場合のみ。残り３パターンはすべてぶつからない。
* N==3 の場合も可能性を全列挙。ぶつからないパターン、１回ぶつかるパターン、２回ぶつかるパターンに分類。２回ぶつかるパターンでは、１回目のぶつかり直後は、１回ぶつかるパターンに帰着したとも見れる。ふーん。
* (2024-02-19)トンネル最終退出者のあたりをつけてみる作戦。
* (2024-02-20)最終退出者候補二人は初期位置で隣り合ってる、という仮説１。一つ隣の人の最終退出時間から自分の最終退出時間を（いわゆるDP的に）求められる、という仮説２。仮説１は手元で試したパターンだと正しそうなんだが、仮説２が怪しい。片方向だけのDPだと明らかに決まらないパターンがある。例えば人iが←、人i+1が→の場合、i+1の最終退出時間はiの情報だけでは決まらない。なので、左右両方向からDPの配列を埋めてくと良いのかと思った。しかし、例えば→→←の場合は両端の最終退出時間はわかんないよなあ。N==3 の場合をうまくいくようなアルゴリズムをもっと考えてみよう。
* (2024-02-23)右から左にdp 配列を（埋めれるとこだけ）埋め、次に左から右に埋める戦略は？
* (2024-02-24)答え見た。そのアイデアは全く浮かばなかった。完敗！

## 6.10

* 仮説「どんな2枚のカードの選び方をしても最終的なカードは変わらない」を立ててみる。パッと何パターンかみたところ正しいっぽい。
* 最終カードが選び方によらなそうなことがわかったので、青と赤の同枚数ペアは無視することに（白は何枚あっても白なんで、拝アンミカ）。あとは青、または赤の連続が何色になるかという問題になり、青青、青青青、青青青青、... と見てくと周期が見えた。無事AC。

## 8.1, 8.2

Python3 のスタック、キューの操作を問う問題。
競プロ界隈だと `collections.deque` を使うと知る：

https://qiita.com/saba/items/107c4237206e31acdbef

deque とは "Double-ended queue" の略語で、「デック」と発音するっぽい：

https://docs.python.org/ja/3/library/collections.html#collections.deque

## 8.6

* 全クエリに対してナイーブに文字列比較すると余裕で TLE
* やはりテキストの前処理が必要かと理解。累積和を使って文字列の ascii 値の総和を事前に計算。クエリ処理時はまず総和を比較し、総和が異なっていたら early return みたいにした。だが、まだTLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50726648
* builtin の `hash()` 関数を使ってみることに。hash の計算自体も文字列全部を舐めるはずだから、クエリごとに計算してたら間に合わんよなーと薄々感じていた。案の定 TLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50726883
* (2024-03-01) 文字列比較の際、先頭からだけではなく後ろからも見てみる猪口才な工夫。無事TLE：
  * https://atcoder.jp/contests/tessoku-book/submissions/50732781
* (2024-03-01) 答えをチラ見。部分文字列のハッシュ値が $O(n^2)$ でなく、 $O(n)$ で計算できるように工夫するっぽい。
* (2024-03-02) ハッシュ関数としてB進法を知る。教科書では長さ n の文字列 S に対し、次のような定義だった： $\sum_{i=0}^{n-1} B^i S[n-(i+1)]$。 自分は $\sum_{i=0}^{n-1} B^i S[i]$ の方がシンプルで良さそうな気がしてた。が、自分のやつだと i 文字目までのハッシュから i+1 文字目までのハッシュを計算する際に $B^i$ を計算しないといけなくなる。これは重い。教科書の定義だと単に $B$ を１つ前のハッシュ値にかければ良いのでコストが低い。やっぱりこういうことも考慮されてるんだな。
* (2024-03-03) B 進法を使ったハッシュ計算を実装する。１）部分文字列のハッシュ値がマイナスになりうる点、２）ハッシュ値の事前計算が Off-by-one エラーになった点（空文字に対してもハッシュ値を定義し、一文字のハッシュ値をインデックス 1 に格納すべきだった）に苦しんだ。なんとかAC。疲れた。

## 8.7

* (2024-03-04) 必ずしも綺麗なループになるとは限らんな。部分的なループになることもある 1->2->3->2 とか。
* (2024-03-05) タイトルになってるダブリングの競プロ的な意味を調べる：
  * https://zenn.dev/fjnkt98/articles/3c0c21778b6101
  * > 全体の要素数 $N$ 個に対し、それぞれの要素から１回遷移した移動先が与えられたとする。このとき、 $K$ 回遷移した時の到達点を高速に求めるアルゴリズムの１つ。ナイーブな方法だと $\mathcal{O}(K)$ だが、ダブリングだと $\mathcal{O}(N\log K)$ で計算できる。
* (2024-03-05) A57 の条件は $N\le 10^5$、$K\le 10^9$ で最大 $10^5$ 個のクエリに答えないといけない。 $\mathcal{O}(N\log K)$ だと間に合わなくないか？