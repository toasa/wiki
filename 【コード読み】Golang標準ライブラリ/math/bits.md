### `func OnesCount64(x uint64) int`

- 概要
    - `x` のビット表現の中で `1` のビットの数を取得する
- 実装
    - なかなか面白い
        - アイデアの引用元は "Hacker's Delight" の第五章 Counting Bits
    - 肝となる考えは分割統治法 (Devide and conquer)
    - 64 bit の 1 の数を数えたい場合、2 つの 32bit のそれぞれの 1 の数を数え足し合わせれば良い。32 bit の 1 のビットを数えたい場合 16 bit に分割しそれぞれ求めた上で足し合わせれば良い。これを再帰的に続けていく。
    - 再帰の基底条件は 2 つのビット列の 1 のビットの数である（たとえば 0b11 => 2, 0b01 => 1, 0b00 => 0 など）。
        - これは (x & 0b01) + ((x >> 1) & 0b01) とすればよい

### `func ReverseByte32(x uint32) uint32`

- 概要
    - 4 バイトのバイト列の順序を反転させる
    - 例えば 0x89ABCDEF => 0xEFCDAB98
- 実装
    - 1 バイト目と 2 バイト目、3 バイト目と 4 バイト目をそれぞれ入れ替える
    - そして前半の 2 バイトと後半の 2 バイトを入れ替える

### `func Len8(x uint8) int`

- 概要
    - `x` を表現するために必要な最小のビット数を取得する
- 実装
    - `bits_tables.go` の中に `var len8tab [256]uint8` のテーブルを用意している
