### `byte` 型のスライスを Unicode のコードポイントの列として扱うときの典型的な処理

- `rune` と `[]byte` のおさらい
    - `あ` のコードポイントは `0x3042`
        - 整数値 `0x3042` が Go 言語では `rune` 型として扱う
    - `あ` のコードポイントを UTF8 にエンコードすると `[0xE3, 0x81, 0x82]` という 3 バイトの列になる
        - Go 言語では `[]byte` 型として扱う
        - `bytes` バッケージは `byte` 型のスライスを扱うことが多く、このスライスを `UTF8` にエンコードされたコードポイントの列とみなすことができる
            - たとえば `あいう`
                - `あ`, `い`, `う` のコードポイントはそれぞれ `0x3042`, `0x3044`, `0x3046`
                - UTF8 エンコードされた値はそれぞれ `[0xE3, 0x81, 0x82]`, `[0xE3, 0x81, 0x84]`, `[0xE3, 0x81, 0x86]` となる
                - Go では文字列を UTF8 エンコードする
                - そのため文字列 `"あいう"` は `byte` 型のスライス `[]byte{ 0xE3, 0x81, 0x82, 0xE3, 0x81, 0x84, 0xE3, 0x81, 0x86 }` として表現される
- 典型的な処理のコード例
    - ```go
      start := 0
      for start < len(s) {
          wid := 1
          r := rune(s[start])

          // r が 2 バイト以上で表される場合
          if r >= utf8.RuneSelf {
              // バイト幅 wid を更新する
              r, wid = utf8.DecodeRune(s[start:])
          }

          //
          // r に対する処理
          //

          start += wid
      }
      ```

#### `func IndexByte(b []byte, c byte) int`

- 概要
    - byte 型のスライス `b` の中で `c` が最初に登場するインデックスを返す
    - 見つからない場合 `-1` を返す
- 実装
    - コードでは `internal/bytealg` パッケージの `IndexByte` メソッドを呼んでいる
    - `bytealg` を見てみよう
        - `wasm`, `arm64`, `ppc64`, `ricv64` などは専用のアセンブラで定義されていた
        - `internal/bytealg/indexbyte_generic.go` も用意されており、これはシンプルな実装だった
            - `b` の中身を range loop でイテレートし、`c` と一致したらそのインデックスを返す

#### `func Equal(a, b []byte) bool`

- 概要
    - `a` と `b` の長さを比べて、for-loop で要素一致により判定しているのかと予想したら違った
    - バイト型のスライスを文字列にキャストし、文字列同士の一致演算子で比較していた

#### `func explode(s []byte, n int) [][]byte`

- 概要
    - `s` を Unicode 文字単位に分割し、`[]byte` 型のスライスとして返す
    - ただし上限が `n`
- 実装
    - コードの中でスライス `s` に対し `s[0:size:size]` と書かれていた
    - なによこれと思ったらスライシングの一種らしい
    - 通常のスライシングは `s[l:r]` で行い、長さ `r-l` のスライスを生成する
    - `[]` 内の３つ目の値はキャパシティを設定できる
    - つまり `s := []int{ 0, 1, 2, 3, 4, 5, 6 }` の場合、 `s_ := s[:3:4]` は長さ `3` キャパシティ `4` のスライスを生成する

#### `func Count(s, sep []byte) int`

- 概要
    - `s` の中に登場する `sep` の数をカウントする
    - カウントは重複しない
        - つまり `s := bbbb` で `sep := bb` の場合カウントは `2`

#### `func LastIndex(s, sep []byte) int`

- 概要
    - `s` の中に登場する `sep` の中で最後のもののインデックスを返す
- 実装
    - `len(sep) == 1` の場合、つまり `sep` が `byte` 型の場合は特にかんたん
        - `for` ループにより `s` の最後のインデックスから先頭までをデクリメントし、`sep` と一致したらそのインデックスを返す
    - 一般的な場合は Rabin-Karp search を使っていた
        - Rabin-Karp string search algorithm
            - 概要
                - ハッシュ関数を利用してテキストからパターンを探す文字列検索アルゴリズムの一種
                - 1つのパターンの検索にはあまり用いられないが、複数パターンの検索には効果的
            - 計算量
                - `n` をテキストの文字数、 `m` をパターンの文字数とすると、平均 `O(n)` の実行時間
                - ごくまれに最悪の場合として `O(mn)` となる
                - `k (k > 1)` 個のパターンのいずれかにマッチする検索の実行時間は `k` によらず `O(n)` になるという独特の利点を持つ
            - 実装
                - パターンのハッシュ値とテキストのサブ文字列のハッシュ値を一致比較することで、文字列一致を判定する
                    - もちろんハッシュ値が同じでも文字列として異なる場合はある
                    - Go の擬似コード:
                        - ```go
                          func RabinKarp(text string, pat string) int {
                              n := len(text)
                              m := len(pat)
                              pat_h := hash(pat)
                              for i := range text {
                                  subText := text[i:i+m]
                                  // サブテキストに対し逐次ハッシュ値を求める。
                                  // 通常のハッシュ値計算をすると計算量が `O(m)` になり
                                  // アルゴリズム全体の計算量が `O(mn)` になってしまう。
                                  // これではナイーブな文字列探索と変わらないので、
                                  // ローリングハッシュと呼ばれる特殊なハッシュ値計算を行う。
                                  subText_h := hash(subText)
                                  if subText_h == pat_h {
                                      if subText == pat {
                                          return i
                                      }
                                  }
                              }

                              // Not found
                              return -1
                          }
                          ```
    - ソースコードの Rabin-Karp search ではハッシュ値計算に素数 `16777619` を基数として使用していた

#### `func Split(s, sep []byte) [][]byte`

- 概要
    - 文字列 `s` に対し `sep` をセパレータとし文字列のスライスを返す
        - ここでの文字列とは byte 型のスライスのこと
    - 例えば `s := aa$$bb$$cc$$dd`, `sep := $$` の場合 `[]byte{ "aa", "bb", "cc", "dd" }` が返される

#### `func genSplit(s, sep []byte, sepSave, n int) []byte`

- 概要
    - `SplitXXX` 系の関数は内部でこの関数を呼び出す
    - 文字列 `s` の中で `sep` **以外** のサブ文字列をスライスに入れて返す
- 実装
    - 状況は下図
        - ```
              +-                                      -+
              | ------(sep)----(sep)----------(sep)--- |
              +-                                      -+
               \                                      /
                ---------------- s -------------------
          ```
    - `n` に関する for-loop で以下をくりかえす
        - `Index(s, sep)` を呼び出し、先頭のセパレータの開始インデックス `m` を取得する
        - `s[:m]` が取り出したい部分なため戻り値用のスライスに格納する
        - セパレータを読み飛ばす
            - `s = s[m+len(sep):]`

#### `func Fields(s []byte) [][]byte`

- 概要
    - 空白文字(`\n`, `\t`, ` `, etc...) で分割される文字列をスライスに格納し返す
    - `Field` って名前ピンと来ないんだが🤔
- 実装
    - 例えば以下のような状況
        - `s := aaaa____bb__cccc___` (`_` は空白)
    - まず結果として返す文字列のスライスの要素数を求める
        - 上の例だと `[]byte{ "aaaa", "bb", "cccc" }` の長さなので `3`
        - なかなか思いつかない実装だった
            - 概略は以下の通り
                - 直前が空白である文字をカウントすればよいため、直前の文字の状態を格納する `wasSpace` と現在検査中の文字の状態を格納する `isSpace` を使う。
                - 下図だと `^` の場所をカウントしたい
                - ```
                  aaaa____bb__cccc___
                  ^       ^   ^
                  ```
            - 詳細な実装は以下
                - グローバル変数 `asciiSpace = [256]uint8 { '\t': 1, '\n': 1, ' ': 1 }` を定義しておく
                - ```go
                  n := 0
                  wasSpace := 1
                  for _, c := range s {
                      isSpace := asciiSpace[c]
                      n += wasSpace & ^isSpace
                      wasSpace = isSpace
                  }
                  ```
                - `n` が求めたい結果になる
    - フィールドの数がわかったのであとは `s` をスライシングしていく
        - フィールド開始文字と現在検査中の文字、２つのインデックスを管理しながらスパスパ切っていく
            - 前者が `fieldStart`、後者が `i`
        - あらかじめ用意していたスライス `a` にスライスしたサブ文字列を格納する
            - `a[na] = s[fieldStart:i:i]`
                - 右辺は長さ `i-fieldStart` 容量 `i-1` のスライス
    - `s` の最後の文字が空白で**ない**場合、戻り値のスライスに追加されていないので別途処理する

#### `func FieldsFunc(s []byte, f func(rune) bool) [][]byte`

- 概要
    - `f` が `true` を返す文字をセパレータとして使用する
- 使用例
    - `s := "a.b,c.d"` のように `.` または `,` をセパレータとして文字列分解をしたい場合
    - ```go
      f := func(r rune) bool {
          if r == '.' || r == ',' {
              return true
          }
      }
      ```
    - `f` を上のように定義すれば、`bytes.FieldsFunc(s, f)` は `[]byte{ "a", "b", "c", "d" }` を返す

#### `func Join(s [][]byte, sep []byte) []byte`

- 概要
    - `s` に含まれる各文字列を `sep` で連結し、新しい文字列を返す

#### `func Map(mapping func(r rune) rune, s []byte) []byte`

- 概要
    - 関数型言語の `Map` 関数のような動作
    - `s` の各文字に対し `mapping` を施した結果を、連結して `byte` 型スライスとして返す
    - イメージはこんなかんじ
        - ```
              []byte{  r1,  r2,  r3 }
                       |    |    |
                       |    |    | mapping
                       v    v    v
              []byte{ r1', r2', r3' }
          ```

#### `func Repeat(b []byte, count int) []byte`

- 概要
    - `b` を `count` 回繰り返し、結果を連結した新しい `byte` 型のスライスを生成する
- 実装
    - あらかじめ返り値となるスライスを用意しておく
        - `nb := make([]byte, len(b) * count)`
    - `nb` に対し `b` をコピーしていく
        - このとき、`1`倍, `2` 倍, `4` 倍とコピーする長さを線形に増やす
    - Go の `copy(dst, src)` って `dst` の容量を越えても問題ないのか、なるほど
        - 例えば `s := []byte{ 3, 3, 3, 3, 3 }`, `d := make([]byte, 2)` の場合に `n := copy(d, s)` は成功し、`d == []byte { 3, 3 }` となり `n == 2` とコピーしたバイト数が返される

#### `func IndexFunc(s []byte, f func(r rune) bool) int`

- 概要
    - `s` をコードポイントの列とみなしたとき、初めて `f` が `true` となるインデックスを返す

#### `func Replace(s, old, new []byte, n int) []byte`

- 概要
    - スライス `s` を中に登場するサブスライス `old` を `new` に置換する
    - 置換する数は `n` で指定する
- 実装
    - 返り値となるスライス `t` を用意する
    - 図は以下の通り (`w`, `start`, `w` はコード登場する変数)
        - ```
                         old         old       old
            s     ------|---|-------|---|-----|---|----
                  ^     ^
                  |     |
                start   j

                                 | |
                                 | |     Replace
                                 | |
                                 \ /
                                  v


                          new           new          new
            t     ------|-----|-------|-----|-----|------|----
                  ^
                  |
                  w
          ```



