https://www.oreilly.co.jp/books/9784873113623/

# ２章 ファイルI/O

## 2.7 ファイルシーク：lseek()

### 2.7.1 ファイルサイズを超えたシーク

ファイルサイズを超えてシークを行った後、書き込みを行った場合、
今までのファイル末尾からシーク場までを 0 で埋められる。
この 0 で埋められた領域を穴またはホール (hole) と言う。
man lseek にも書いてた。

## 2.11 カーネル内の動作

### 2.11.2 ページキャッシュ

ページキャッシュとは、アクセスしたばかりの、ファイルシステムが持つディスク上のデータをメモリ上に蓄えておくこと。

### 2.11.3 ページライトバック

ページライトバックとは、dirty バッファ（アプリが書き込み操作を行ったことにより、メモリ上のデータが新しく、ディスク上のデータが古くなること）をディスクへ書き出すこと、つまりメモリ上のデータとディスク上のファイルの同期。

ライトバックが発生する状況

1. 空きメモリ量が設定値を下回った場合
2. バッファが dirty になってから経過した時間が設定値を超えた場合

# 4章 高度なファイルI/O

## 4.3 ファイルをメモリへマッピングする

どんな時に `mmap()` を使うべきか？
4.3.4, 4.3.5 の利点と欠点をまとめると、
以下のような場合に `mmap()` を使うべき：

* マッピングするファイルサイズが大きい時
* マッピングするサイズがページサイズで割り切れる時

### 4.3.4, 4.3.5  mmap() の利点と欠点

`read()`, `write()` と比較した場合の、`mmap()` の利点：

* アプリ側のバッファとのコピーが発生しない。
* ページフォルトは発生しうるが、システムコールやコンテキストスイッチのオーバーヘッドが発生しない。

`mmap()` の欠点：

* マッピングは常にページサイズで行われるため、ファイルサイズが小さい場合は無駄が増える。たとえばファイルサイズが 7B でページサイズが 4KB の場合、4089 B が無駄になる。

## 4.4 ファイルI/Oのヒント/アドバイスを与える

`posix_fadvise()` システムコールでアドバイスを与える。
アドバイスの１つに `POSIX_FADV_DONTNEED` があり、
指定したデータをこの後すぐにはアクセスしない旨を、カーネルに伝えることができる。
ユースケースの例も挙げられていて、たとえば動画ストリーミング。
ストリーミングの場合、大量の I/O を行うため、すぐにページキャッシュを埋め尽くす。
しかし、一度 I/O したデータは通常再度アクセスはしないので、このキャッシュは無駄になる。
なので `POSIX_FADV_DONTNEED` でカーネルにキャッシュの破棄を伝える。

## 4.5 2種類の同期/非同期

* Synchronous / Asynchronous
  * ユーザのバッファとカーネルのバッファとの同期が取れているか否か。
  * Synchronous
    * 書き込み：データが少なくともカーネル内のバッファまで書き込まれるまでリターンしない。
    * 読み込み：ユーザ空間のバッファに読み取られるまでリターンしない。
  * Asynchronous
    * 書き込み：データがカーネルバッファに書き込まれる**前に**リターンすることがある。
    * 読み込み：データがユーザのバッファに読み込まれて有効になる前にリターンすることがある。
* Synchronized / Nonsynchronized
  * カーネルのバッファとディスク上のデータとの同期が取れているか否か。
  * Synchronized
    * 書き込み：データをディスクまで書き出し（ライトバック）、ディスク上のデータとカーネル内のバッファとが同期が取れていることを保証する。
    * 読み込み：常に最新のデータを返す。

Unix の書き込みと読み込みの通常の動作：

- 書き込み：Syncronous かつ Nonsynchronized
- 読み込み：Syncronous かつ Synchronized