https://www.oreilly.co.jp/books/9784873113623/

# ２章 ファイルI/O

## 2.7 ファイルシーク：lseek()

### 2.7.1 ファイルサイズを超えたシーク

ファイルサイズを超えてシークを行った後、書き込みを行った場合、
今までのファイル末尾からシーク場までを 0 で埋められる。
この 0 で埋められた領域を穴またはホール (hole) と言う。
man lseek にも書いてた。

## 2.11 カーネル内の動作

### 2.11.2 ページキャッシュ

ページキャッシュとは、アクセスしたばかりの、ファイルシステムが持つディスク上のデータをメモリ上に蓄えておくこと。

### 2.11.3 ページライトバック

ページライトバックとは、dirty バッファ（アプリが書き込み操作を行ったことにより、メモリ上のデータが新しく、ディスク上のデータが古くなること）をディスクへ書き出すこと、つまりメモリ上のデータとディスク上のファイルの同期。

ライトバックが発生する状況

1. 空きメモリ量が設定値を下回った場合
2. バッファが dirty になってから経過した時間が設定値を超えた場合

# 4章 高度なファイルI/O

## 4.3 ファイルをメモリへマッピングする

どんな時に `mmap()` を使うべきか？
4.3.4, 4.3.5 の利点と欠点をまとめると、
以下のような場合に `mmap()` を使うべき：

* マッピングするファイルサイズが大きい時
* マッピングするサイズがページサイズで割り切れる時

### 4.3.4, 4.3.5  mmap() の利点と欠点

`read()`, `write()` と比較した場合の、`mmap()` の利点：

* アプリ側のバッファとのコピーが発生しない。
* ページフォルトは発生しうるが、システムコールやコンテキストスイッチのオーバーヘッドが発生しない。

`mmap()` の欠点：

* マッピングは常にページサイズで行われるため、ファイルサイズが小さい場合は無駄が増える。たとえばファイルサイズが 7B でページサイズが 4KB の場合、4089 B が無駄になる。

## 4.4 ファイルI/Oのヒント/アドバイスを与える

`posix_fadvise()` システムコールでアドバイスを与える。
アドバイスの１つに `POSIX_FADV_DONTNEED` があり、
指定したデータをこの後すぐにはアクセスしない旨を、カーネルに伝えることができる。
ユースケースの例も挙げられていて、たとえば動画ストリーミング。
ストリーミングの場合、大量の I/O を行うため、すぐにページキャッシュを埋め尽くす。
しかし、一度 I/O したデータは通常再度アクセスはしないので、このキャッシュは無駄になる。
なので `POSIX_FADV_DONTNEED` でカーネルにキャッシュの破棄を伝える。

## 4.5 2種類の同期/非同期

* Synchronous / Asynchronous
  * ユーザのバッファとカーネルのバッファとの同期が取れているか否か。
  * Synchronous
    * 書き込み：データが少なくともカーネル内のバッファまで書き込まれるまでリターンしない。
    * 読み込み：ユーザ空間のバッファに読み取られるまでリターンしない。
  * Asynchronous
    * 書き込み：データがカーネルバッファに書き込まれる**前に**リターンすることがある。
    * 読み込み：データがユーザのバッファに読み込まれて有効になる前にリターンすることがある。
* Synchronized / Nonsynchronized
  * カーネルのバッファとディスク上のデータとの同期が取れているか否か。
  * Synchronized
    * 書き込み：データをディスクまで書き出し（ライトバック）、ディスク上のデータとカーネル内のバッファとが同期が取れていることを保証する。
    * 読み込み：常に最新のデータを返す。

Unix の書き込みと読み込みの通常の動作：

- 書き込み：Syncronous かつ Nonsynchronized
- 読み込み：Syncronous かつ Synchronized

# 6章 高度なプロセス管理

## 6.4 プロセッサアフィニティ

プロセッサアフィニティとは、プロセスとCPUとの結びつきの程度。
CPU は、それぞれにキャッシュを持つため、プロセスの実行は可能な限り同じ CPU 上で行った方が（他の CPU で実行してしまうとそれまでのキャッシュが無駄になるとい意味で）効率的。

# 7章 ファイル、ディレクトリの管理

## 7.3 ファイルのリンク

### 7.3.3 ファイルのアンリンク / 削除

プロセスがファイルをオープンしている間は、`unlink()` を読んでも、ファイルは削除されない。
ファイルがクローズされ、オープンしているプロセスが存在しなくなった時点で、カーネルはファイルを削除する。

## 7.5 デバイスノード

### 7.5.1

* `/dev/null` への読み取りは EOF が返される。
* `/dev/zero` への読み取りは null 文字が返される。
* `/dev/full` への読み取りは null 文字が返される。書き込みはエラー (`ENOSPC`) となる

# 8章 メモリ管理

## 8.4 無名メモリマッピング

* 内部フラグメンテーション：要求されたサイズよりも大きなメモリ領域を返す問題
* 外部フラグメンテーション：要求されたサイズ分の未使用メモリがあるにもかかわらず、複数のメモリ領域に分断されている状態

### 8.4.1 無名メモリマッピングの作成

Linux では `mmap()` に `MAP_ANONUMOUS` フラグをつけて、作成する。

`malloc()` は、閾値を超えたメモリサイズを割り当てる場合は、ヒープから割り当てず、無名メモリマッピングを使う。[man malloc](https://man7.org/linux/man-pages/man3/malloc.3.html) の NOTES：

>  Normally, malloc() allocates memory from the heap, and adjusts the size of the heap as required, using sbrk(2). When allocating blocks of memory larger than MMAP_THRESHOLD bytes, the glibc malloc() implementation allocates the memory as a private anonymous mapping using mmap(2).  MMAP_THRESHOLD is 128 kB by default, but is adjustable using mallopt(3).

## 8.7 スタック上のメモリ割り当て

* `alloca()` でスタック上に動的にメモリを割り当てることができる。割り当てたメモリ領域は `free()` してはいけない。
* C99 で可変サイズ配列 (variable-length array, VLA) が導入された。以下みたいなやつ：
  * ```c
    void foo(int size) {
      int arr[size];
    }
    ```

## 8.9 メモリ操作

* バイト設定：`memset()`
* バイト比較：`memcmp()`
* バイト移動：`memmove()`。src と dst に重なりがあってもよい。
* バイト検索：`memchr()`
* バイトの「意味不明化」：`memfrob()`


２つの構造体を `memcmp()` で比較することはできない。
構造体の内部にはパディングが含まれており、パディング部分は未初期化の不定値であるため。

## 8.10 メモリのロック

アプリケーションは、メモリ領域をディスクにスワップアウトさせず、物理メモリに留まらせることができる。
このような動作をメモリのロックという。
メモリをロックしたい場面：

* 時間制約に厳しい場合。ページフォルトの処理時間を許容できないような、時間に厳しいアプリの場合。
* セキュリティ。例えばユーザの秘密鍵が暗号化されずに、ディスクに書き出されてしまうと、セキュリティ上の問題がある。

ロックする方法：

* `mlock()`：アドレス空間の一部をロックする。
* `mlockall()`：アドレス空間全体をロックする。

